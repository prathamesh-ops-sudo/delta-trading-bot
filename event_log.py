"""
Unified Event Log - Institutional-Grade Measurement & Auditability
Tier 1: Aladdin-like Decision Tracking

Logs every decision cycle:
- Market snapshot (prices, indicators, regime)
- Features used for decision
- Signals generated
- Confidence adjustments (macro, news, adaptive, uncertainty)
- Gating decisions (which gates passed/rejected)
- Order request and broker acknowledgment
- Fill details and slippage
- Position modifications (trailing, BE, partial close)
- Final close with PnL attribution

Also includes:
- Transaction Cost Analysis (TCA)
- Reconciliation (internal vs MT5 state)
"""

import logging
import json
import os
import sqlite3
import threading
import time
from datetime import datetime, timedelta
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Optional, Tuple, Any
from enum import Enum
import statistics
import uuid

logger = logging.getLogger(__name__)


class EventType(Enum):
    """Types of events in the decision lifecycle"""
    # Decision cycle events
    MARKET_SNAPSHOT = "market_snapshot"
    SIGNAL_GENERATED = "signal_generated"
    CONFIDENCE_ADJUSTMENT = "confidence_adjustment"
    GATE_CHECK = "gate_check"
    TRADE_DECISION = "trade_decision"
    
    # Order lifecycle events
    ORDER_REQUEST = "order_request"
    ORDER_ACKNOWLEDGED = "order_acknowledged"
    ORDER_FILLED = "order_filled"
    ORDER_REJECTED = "order_rejected"
    ORDER_MODIFIED = "order_modified"
    
    # Position events
    POSITION_OPENED = "position_opened"
    POSITION_MODIFIED = "position_modified"
    TRAILING_STOP_UPDATE = "trailing_stop_update"
    BREAKEVEN_TRIGGERED = "breakeven_triggered"
    PARTIAL_CLOSE = "partial_close"
    POSITION_CLOSED = "position_closed"
    
    # System events
    RECONCILIATION = "reconciliation"
    TCA_ANALYSIS = "tca_analysis"
    SYSTEM_ERROR = "system_error"
    EA_CONNECTED = "ea_connected"
    EA_DISCONNECTED = "ea_disconnected"


@dataclass
class MarketSnapshot:
    """Snapshot of market state at decision time"""
    timestamp: datetime
    symbol: str
    bid: float
    ask: float
    spread_pips: float
    
    # Technical indicators
    rsi: float = 0.0
    adx: float = 0.0
    atr: float = 0.0
    macd: float = 0.0
    bb_position: float = 0.0  # -1 to 1 (lower to upper band)
    
    # Regime
    regime: str = "unknown"
    mtf_bias: str = "neutral"
    mtf_alignment: float = 0.0
    
    # Macro context
    dxy_trend: str = "unknown"
    vix_level: str = "unknown"
    macro_regime: str = "neutral"
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['timestamp'] = self.timestamp.isoformat()
        return d


@dataclass
class SignalEvent:
    """Signal generated by a strategy"""
    timestamp: datetime
    symbol: str
    strategy: str
    direction: str  # BUY or SELL
    base_confidence: float
    entry_reason: str
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['timestamp'] = self.timestamp.isoformat()
        return d


@dataclass
class ConfidenceAdjustment:
    """Record of confidence adjustment"""
    source: str  # macro, news, adaptive, uncertainty, session_quality
    original_confidence: float
    adjusted_confidence: float
    adjustment_factor: float
    reason: str
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class GateCheckResult:
    """Result of a trade gate check"""
    gate_name: str
    passed: bool
    reason: str
    details: Dict = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class OrderEvent:
    """Order lifecycle event"""
    timestamp: datetime
    order_id: str
    symbol: str
    direction: str
    order_type: str  # market, limit, stop
    requested_price: float
    requested_size: float
    stop_loss: float
    take_profit: float
    
    # Fill details (populated after fill)
    fill_price: float = 0.0
    fill_size: float = 0.0
    fill_time: Optional[datetime] = None
    slippage_pips: float = 0.0
    
    # Status
    status: str = "pending"  # pending, filled, rejected, cancelled
    rejection_reason: str = ""
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['timestamp'] = self.timestamp.isoformat()
        if self.fill_time:
            d['fill_time'] = self.fill_time.isoformat()
        return d


@dataclass
class PositionEvent:
    """Position lifecycle event"""
    timestamp: datetime
    position_id: str
    symbol: str
    direction: str
    
    # Entry details
    entry_price: float
    entry_time: datetime
    position_size: float
    
    # Current state
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    
    # Stop levels
    stop_loss: float = 0.0
    take_profit: float = 0.0
    trailing_stop: float = 0.0
    
    # Exit details (populated on close)
    exit_price: float = 0.0
    exit_time: Optional[datetime] = None
    realized_pnl: float = 0.0
    pnl_pips: float = 0.0
    
    # Attribution
    strategy: str = ""
    entry_confidence: float = 0.0
    exit_reason: str = ""
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['timestamp'] = self.timestamp.isoformat()
        d['entry_time'] = self.entry_time.isoformat()
        if self.exit_time:
            d['exit_time'] = self.exit_time.isoformat()
        return d


@dataclass
class DecisionCycle:
    """Complete decision cycle with all events"""
    cycle_id: str
    timestamp: datetime
    symbol: str
    
    # Market state
    snapshot: Optional[MarketSnapshot] = None
    
    # Signals
    signals: List[SignalEvent] = field(default_factory=list)
    selected_signal: Optional[SignalEvent] = None
    
    # Confidence adjustments
    adjustments: List[ConfidenceAdjustment] = field(default_factory=list)
    final_confidence: float = 0.0
    
    # Gate checks
    gate_results: List[GateCheckResult] = field(default_factory=list)
    all_gates_passed: bool = False
    
    # Decision
    decision: str = "no_trade"  # trade, no_trade, rejected
    rejection_reason: str = ""
    
    # Order (if trade decision)
    order: Optional[OrderEvent] = None
    
    # Duration
    processing_time_ms: float = 0.0
    
    def to_dict(self) -> Dict:
        return {
            'cycle_id': self.cycle_id,
            'timestamp': self.timestamp.isoformat(),
            'symbol': self.symbol,
            'snapshot': self.snapshot.to_dict() if self.snapshot else None,
            'signals': [s.to_dict() for s in self.signals],
            'selected_signal': self.selected_signal.to_dict() if self.selected_signal else None,
            'adjustments': [a.to_dict() for a in self.adjustments],
            'final_confidence': self.final_confidence,
            'gate_results': [g.to_dict() for g in self.gate_results],
            'all_gates_passed': self.all_gates_passed,
            'decision': self.decision,
            'rejection_reason': self.rejection_reason,
            'order': self.order.to_dict() if self.order else None,
            'processing_time_ms': self.processing_time_ms
        }


@dataclass
class TCAMetrics:
    """Transaction Cost Analysis metrics"""
    symbol: str
    period_start: datetime
    period_end: datetime
    
    # Trade counts
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    
    # Slippage analysis
    avg_slippage_pips: float = 0.0
    max_slippage_pips: float = 0.0
    total_slippage_cost: float = 0.0
    
    # Spread analysis
    avg_spread_at_entry: float = 0.0
    avg_spread_at_exit: float = 0.0
    
    # Execution quality
    fill_rate: float = 1.0  # Percentage of orders filled
    avg_fill_time_ms: float = 0.0
    
    # Cost breakdown
    spread_cost_total: float = 0.0
    slippage_cost_total: float = 0.0
    total_transaction_cost: float = 0.0
    
    # Performance impact
    gross_pnl: float = 0.0
    net_pnl: float = 0.0  # After transaction costs
    cost_as_pct_of_pnl: float = 0.0
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['period_start'] = self.period_start.isoformat()
        d['period_end'] = self.period_end.isoformat()
        return d


@dataclass
class ReconciliationResult:
    """Result of position reconciliation"""
    timestamp: datetime
    
    # Internal state
    internal_positions: Dict[str, Dict] = field(default_factory=dict)
    internal_balance: float = 0.0
    
    # MT5 state
    mt5_positions: Dict[str, Dict] = field(default_factory=dict)
    mt5_balance: float = 0.0
    
    # Discrepancies
    position_mismatches: List[Dict] = field(default_factory=list)
    balance_mismatch: float = 0.0
    
    # Status
    is_synced: bool = True
    requires_action: bool = False
    recommended_action: str = ""
    
    def to_dict(self) -> Dict:
        d = asdict(self)
        d['timestamp'] = self.timestamp.isoformat()
        return d


class EventLogger:
    """
    Unified event logger for institutional-grade auditability.
    Stores all events in SQLite for durability and queryability.
    """
    
    def __init__(self, db_path: str = "data/event_log.db"):
        self.db_path = db_path
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        
        self._lock = threading.Lock()
        self._init_database()
        
        # In-memory cache for current decision cycles
        self._current_cycles: Dict[str, DecisionCycle] = {}
        
        # TCA data
        self._trade_records: List[Dict] = []
        
        logger.info(f"EventLogger initialized with database: {db_path}")
    
    def _init_database(self):
        """Initialize SQLite database with required tables"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Decision cycles table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS decision_cycles (
                    cycle_id TEXT PRIMARY KEY,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    decision TEXT NOT NULL,
                    final_confidence REAL,
                    processing_time_ms REAL,
                    data JSON NOT NULL
                )
            ''')
            
            # Events table (for all event types)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS events (
                    event_id TEXT PRIMARY KEY,
                    timestamp TEXT NOT NULL,
                    event_type TEXT NOT NULL,
                    symbol TEXT,
                    cycle_id TEXT,
                    data JSON NOT NULL
                )
            ''')
            
            # Orders table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    order_id TEXT PRIMARY KEY,
                    timestamp TEXT NOT NULL,
                    symbol TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    requested_price REAL,
                    fill_price REAL,
                    slippage_pips REAL,
                    status TEXT,
                    data JSON NOT NULL
                )
            ''')
            
            # Positions table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS positions (
                    position_id TEXT PRIMARY KEY,
                    symbol TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    entry_time TEXT NOT NULL,
                    exit_time TEXT,
                    entry_price REAL,
                    exit_price REAL,
                    realized_pnl REAL,
                    strategy TEXT,
                    data JSON NOT NULL
                )
            ''')
            
            # TCA table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS tca_reports (
                    report_id TEXT PRIMARY KEY,
                    timestamp TEXT NOT NULL,
                    symbol TEXT,
                    period_start TEXT,
                    period_end TEXT,
                    data JSON NOT NULL
                )
            ''')
            
            # Reconciliation table
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS reconciliations (
                    recon_id TEXT PRIMARY KEY,
                    timestamp TEXT NOT NULL,
                    is_synced INTEGER,
                    requires_action INTEGER,
                    data JSON NOT NULL
                )
            ''')
            
            # Create indexes
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_events_type ON events(event_type)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_events_symbol ON events(symbol)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_cycles_timestamp ON decision_cycles(timestamp)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_orders_timestamp ON orders(timestamp)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_positions_symbol ON positions(symbol)')
            
            conn.commit()
    
    def start_decision_cycle(self, symbol: str) -> str:
        """Start a new decision cycle and return cycle_id"""
        cycle_id = f"{symbol}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
        
        cycle = DecisionCycle(
            cycle_id=cycle_id,
            timestamp=datetime.now(),
            symbol=symbol
        )
        
        with self._lock:
            self._current_cycles[cycle_id] = cycle
        
        return cycle_id
    
    def log_market_snapshot(self, cycle_id: str, snapshot: MarketSnapshot):
        """Log market snapshot for a decision cycle"""
        with self._lock:
            if cycle_id in self._current_cycles:
                self._current_cycles[cycle_id].snapshot = snapshot
        
        self._log_event(EventType.MARKET_SNAPSHOT, snapshot.symbol, cycle_id, snapshot.to_dict())
    
    def log_signal(self, cycle_id: str, signal: SignalEvent, is_selected: bool = False):
        """Log a signal generated during decision cycle"""
        with self._lock:
            if cycle_id in self._current_cycles:
                self._current_cycles[cycle_id].signals.append(signal)
                if is_selected:
                    self._current_cycles[cycle_id].selected_signal = signal
        
        self._log_event(EventType.SIGNAL_GENERATED, signal.symbol, cycle_id, {
            **signal.to_dict(),
            'is_selected': is_selected
        })
    
    def log_confidence_adjustment(self, cycle_id: str, adjustment: ConfidenceAdjustment):
        """Log a confidence adjustment"""
        with self._lock:
            if cycle_id in self._current_cycles:
                self._current_cycles[cycle_id].adjustments.append(adjustment)
                self._current_cycles[cycle_id].final_confidence = adjustment.adjusted_confidence
        
        self._log_event(EventType.CONFIDENCE_ADJUSTMENT, None, cycle_id, adjustment.to_dict())
    
    def log_gate_check(self, cycle_id: str, result: GateCheckResult):
        """Log a gate check result"""
        with self._lock:
            if cycle_id in self._current_cycles:
                self._current_cycles[cycle_id].gate_results.append(result)
        
        self._log_event(EventType.GATE_CHECK, None, cycle_id, result.to_dict())
    
    def log_trade_decision(self, cycle_id: str, decision: str, reason: str = ""):
        """Log the final trade decision"""
        with self._lock:
            if cycle_id in self._current_cycles:
                cycle = self._current_cycles[cycle_id]
                cycle.decision = decision
                cycle.rejection_reason = reason
                cycle.all_gates_passed = all(g.passed for g in cycle.gate_results)
        
        self._log_event(EventType.TRADE_DECISION, None, cycle_id, {
            'decision': decision,
            'reason': reason
        })
    
    def end_decision_cycle(self, cycle_id: str, processing_time_ms: float = 0.0):
        """End a decision cycle and persist to database"""
        with self._lock:
            if cycle_id not in self._current_cycles:
                return
            
            cycle = self._current_cycles[cycle_id]
            cycle.processing_time_ms = processing_time_ms
            
            # Persist to database
            self._save_decision_cycle(cycle)
            
            # Remove from current cycles
            del self._current_cycles[cycle_id]
    
    def _save_decision_cycle(self, cycle: DecisionCycle):
        """Save decision cycle to database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO decision_cycles 
                    (cycle_id, timestamp, symbol, decision, final_confidence, processing_time_ms, data)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (
                    cycle.cycle_id,
                    cycle.timestamp.isoformat(),
                    cycle.symbol,
                    cycle.decision,
                    cycle.final_confidence,
                    cycle.processing_time_ms,
                    json.dumps(cycle.to_dict())
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to save decision cycle: {e}")
    
    def log_order(self, order: OrderEvent):
        """Log an order event"""
        self._log_event(EventType.ORDER_REQUEST, order.symbol, None, order.to_dict())
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO orders 
                    (order_id, timestamp, symbol, direction, requested_price, fill_price, slippage_pips, status, data)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    order.order_id,
                    order.timestamp.isoformat(),
                    order.symbol,
                    order.direction,
                    order.requested_price,
                    order.fill_price,
                    order.slippage_pips,
                    order.status,
                    json.dumps(order.to_dict())
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log order: {e}")
    
    def log_order_fill(self, order_id: str, fill_price: float, fill_size: float, slippage_pips: float):
        """Log order fill details"""
        self._log_event(EventType.ORDER_FILLED, None, None, {
            'order_id': order_id,
            'fill_price': fill_price,
            'fill_size': fill_size,
            'slippage_pips': slippage_pips,
            'fill_time': datetime.now().isoformat()
        })
        
        # Update order in database
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE orders SET fill_price = ?, slippage_pips = ?, status = ?
                    WHERE order_id = ?
                ''', (fill_price, slippage_pips, 'filled', order_id))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to update order fill: {e}")
        
        # Record for TCA
        self._trade_records.append({
            'order_id': order_id,
            'fill_price': fill_price,
            'slippage_pips': slippage_pips,
            'timestamp': datetime.now()
        })
    
    def log_position(self, position: PositionEvent, event_type: EventType = EventType.POSITION_OPENED):
        """Log a position event"""
        self._log_event(event_type, position.symbol, None, position.to_dict())
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO positions 
                    (position_id, symbol, direction, entry_time, exit_time, entry_price, exit_price, realized_pnl, strategy, data)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    position.position_id,
                    position.symbol,
                    position.direction,
                    position.entry_time.isoformat(),
                    position.exit_time.isoformat() if position.exit_time else None,
                    position.entry_price,
                    position.exit_price,
                    position.realized_pnl,
                    position.strategy,
                    json.dumps(position.to_dict())
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log position: {e}")
    
    def _log_event(self, event_type: EventType, symbol: Optional[str], cycle_id: Optional[str], data: Dict):
        """Log a generic event to the events table"""
        event_id = f"{event_type.value}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO events (event_id, timestamp, event_type, symbol, cycle_id, data)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (
                    event_id,
                    datetime.now().isoformat(),
                    event_type.value,
                    symbol,
                    cycle_id,
                    json.dumps(data)
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log event: {e}")
    
    def log_reconciliation(self, result: ReconciliationResult):
        """Log reconciliation result"""
        recon_id = f"recon_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
        
        self._log_event(EventType.RECONCILIATION, None, None, result.to_dict())
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO reconciliations (recon_id, timestamp, is_synced, requires_action, data)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    recon_id,
                    result.timestamp.isoformat(),
                    1 if result.is_synced else 0,
                    1 if result.requires_action else 0,
                    json.dumps(result.to_dict())
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log reconciliation: {e}")
    
    def log_tca_report(self, metrics: TCAMetrics):
        """Log TCA report"""
        report_id = f"tca_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
        
        self._log_event(EventType.TCA_ANALYSIS, metrics.symbol, None, metrics.to_dict())
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO tca_reports (report_id, timestamp, symbol, period_start, period_end, data)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (
                    report_id,
                    datetime.now().isoformat(),
                    metrics.symbol,
                    metrics.period_start.isoformat(),
                    metrics.period_end.isoformat(),
                    json.dumps(metrics.to_dict())
                ))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to log TCA report: {e}")
    
    def get_recent_cycles(self, symbol: Optional[str] = None, limit: int = 100) -> List[Dict]:
        """Get recent decision cycles"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                if symbol:
                    cursor.execute('''
                        SELECT data FROM decision_cycles 
                        WHERE symbol = ?
                        ORDER BY timestamp DESC LIMIT ?
                    ''', (symbol, limit))
                else:
                    cursor.execute('''
                        SELECT data FROM decision_cycles 
                        ORDER BY timestamp DESC LIMIT ?
                    ''', (limit,))
                
                rows = cursor.fetchall()
                return [json.loads(row[0]) for row in rows]
        except Exception as e:
            logger.error(f"Failed to get recent cycles: {e}")
            return []
    
    def get_events_by_type(self, event_type: EventType, limit: int = 100) -> List[Dict]:
        """Get events by type"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    SELECT data FROM events 
                    WHERE event_type = ?
                    ORDER BY timestamp DESC LIMIT ?
                ''', (event_type.value, limit))
                
                rows = cursor.fetchall()
                return [json.loads(row[0]) for row in rows]
        except Exception as e:
            logger.error(f"Failed to get events: {e}")
            return []
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get event log statistics"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Count decision cycles
                cursor.execute('SELECT COUNT(*) FROM decision_cycles')
                total_cycles = cursor.fetchone()[0]
                
                # Count by decision type
                cursor.execute('''
                    SELECT decision, COUNT(*) FROM decision_cycles 
                    GROUP BY decision
                ''')
                decisions = dict(cursor.fetchall())
                
                # Count orders
                cursor.execute('SELECT COUNT(*) FROM orders')
                total_orders = cursor.fetchone()[0]
                
                # Count positions
                cursor.execute('SELECT COUNT(*) FROM positions WHERE exit_time IS NOT NULL')
                closed_positions = cursor.fetchone()[0]
                
                # Average slippage
                cursor.execute('SELECT AVG(slippage_pips) FROM orders WHERE slippage_pips IS NOT NULL')
                avg_slippage = cursor.fetchone()[0] or 0.0
                
                return {
                    'total_decision_cycles': total_cycles,
                    'decisions_breakdown': decisions,
                    'total_orders': total_orders,
                    'closed_positions': closed_positions,
                    'avg_slippage_pips': avg_slippage
                }
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            return {}


class TransactionCostAnalyzer:
    """
    Transaction Cost Analysis (TCA) for measuring execution quality.
    Tracks slippage, spread costs, and execution timing.
    """
    
    def __init__(self, event_logger: EventLogger):
        self.event_logger = event_logger
        self._trade_data: List[Dict] = []
        
        logger.info("TransactionCostAnalyzer initialized")
    
    def record_trade(
        self,
        symbol: str,
        direction: str,
        intended_price: float,
        actual_price: float,
        spread_at_entry: float,
        position_size: float,
        pnl: float = 0.0
    ):
        """Record a trade for TCA"""
        pip_size = 0.01 if 'JPY' in symbol else 0.0001
        
        if direction == "BUY":
            slippage = (actual_price - intended_price) / pip_size
        else:
            slippage = (intended_price - actual_price) / pip_size
        
        self._trade_data.append({
            'timestamp': datetime.now(),
            'symbol': symbol,
            'direction': direction,
            'intended_price': intended_price,
            'actual_price': actual_price,
            'slippage_pips': slippage,
            'spread_at_entry': spread_at_entry,
            'position_size': position_size,
            'pnl': pnl
        })
    
    def analyze(self, symbol: Optional[str] = None, days: int = 7) -> TCAMetrics:
        """Analyze transaction costs for a period"""
        cutoff = datetime.now() - timedelta(days=days)
        
        # Filter trades
        trades = [t for t in self._trade_data if t['timestamp'] >= cutoff]
        if symbol:
            trades = [t for t in trades if t['symbol'] == symbol]
        
        if not trades:
            return TCAMetrics(
                symbol=symbol or "ALL",
                period_start=cutoff,
                period_end=datetime.now()
            )
        
        # Calculate metrics
        slippages = [t['slippage_pips'] for t in trades]
        spreads = [t['spread_at_entry'] for t in trades]
        pnls = [t['pnl'] for t in trades]
        
        total_trades = len(trades)
        winning_trades = sum(1 for p in pnls if p > 0)
        losing_trades = sum(1 for p in pnls if p < 0)
        
        avg_slippage = statistics.mean(slippages) if slippages else 0.0
        max_slippage = max(slippages) if slippages else 0.0
        avg_spread = statistics.mean(spreads) if spreads else 0.0
        
        gross_pnl = sum(pnls)
        total_slippage_cost = sum(abs(s) * 10 for s in slippages)  # Approximate cost
        total_spread_cost = sum(s * 10 for s in spreads)  # Approximate cost
        total_cost = total_slippage_cost + total_spread_cost
        net_pnl = gross_pnl - total_cost
        
        metrics = TCAMetrics(
            symbol=symbol or "ALL",
            period_start=cutoff,
            period_end=datetime.now(),
            total_trades=total_trades,
            winning_trades=winning_trades,
            losing_trades=losing_trades,
            avg_slippage_pips=avg_slippage,
            max_slippage_pips=max_slippage,
            total_slippage_cost=total_slippage_cost,
            avg_spread_at_entry=avg_spread,
            spread_cost_total=total_spread_cost,
            total_transaction_cost=total_cost,
            gross_pnl=gross_pnl,
            net_pnl=net_pnl,
            cost_as_pct_of_pnl=abs(total_cost / gross_pnl * 100) if gross_pnl != 0 else 0.0
        )
        
        # Log the report
        self.event_logger.log_tca_report(metrics)
        
        return metrics
    
    def get_slippage_by_session(self) -> Dict[str, float]:
        """Get average slippage by trading session"""
        sessions = {
            'sydney': (21, 6),    # 21:00 - 06:00 UTC
            'tokyo': (0, 9),      # 00:00 - 09:00 UTC
            'london': (7, 16),    # 07:00 - 16:00 UTC
            'new_york': (12, 21)  # 12:00 - 21:00 UTC
        }
        
        session_slippage: Dict[str, List[float]] = {s: [] for s in sessions}
        
        for trade in self._trade_data:
            hour = trade['timestamp'].hour
            for session, (start, end) in sessions.items():
                if start <= hour < end or (start > end and (hour >= start or hour < end)):
                    session_slippage[session].append(trade['slippage_pips'])
                    break
        
        return {
            session: statistics.mean(slips) if slips else 0.0
            for session, slips in session_slippage.items()
        }


class PositionReconciler:
    """
    Reconciles internal position state with MT5 account state.
    Detects and reports discrepancies.
    """
    
    def __init__(self, event_logger: EventLogger):
        self.event_logger = event_logger
        self._internal_positions: Dict[str, Dict] = {}
        self._internal_balance: float = 0.0
        
        logger.info("PositionReconciler initialized")
    
    def update_internal_state(self, positions: Dict[str, Dict], balance: float):
        """Update internal position state"""
        self._internal_positions = positions.copy()
        self._internal_balance = balance
    
    def reconcile(self, mt5_positions: Dict[str, Dict], mt5_balance: float) -> ReconciliationResult:
        """Reconcile internal state with MT5 state"""
        result = ReconciliationResult(
            timestamp=datetime.now(),
            internal_positions=self._internal_positions.copy(),
            internal_balance=self._internal_balance,
            mt5_positions=mt5_positions.copy(),
            mt5_balance=mt5_balance
        )
        
        # Check balance mismatch
        result.balance_mismatch = abs(self._internal_balance - mt5_balance)
        if result.balance_mismatch > 0.01:  # More than 1 cent difference
            result.is_synced = False
        
        # Check position mismatches
        all_symbols = set(self._internal_positions.keys()) | set(mt5_positions.keys())
        
        for symbol in all_symbols:
            internal = self._internal_positions.get(symbol)
            mt5 = mt5_positions.get(symbol)
            
            if internal and not mt5:
                result.position_mismatches.append({
                    'symbol': symbol,
                    'type': 'missing_in_mt5',
                    'internal': internal,
                    'mt5': None
                })
                result.is_synced = False
            elif mt5 and not internal:
                result.position_mismatches.append({
                    'symbol': symbol,
                    'type': 'missing_internally',
                    'internal': None,
                    'mt5': mt5
                })
                result.is_synced = False
            elif internal and mt5:
                # Check for size/direction mismatch
                if internal.get('size') != mt5.get('size') or internal.get('direction') != mt5.get('direction'):
                    result.position_mismatches.append({
                        'symbol': symbol,
                        'type': 'size_mismatch',
                        'internal': internal,
                        'mt5': mt5
                    })
                    result.is_synced = False
        
        # Determine recommended action
        if not result.is_synced:
            result.requires_action = True
            if result.position_mismatches:
                result.recommended_action = "Sync positions with MT5 state"
            elif result.balance_mismatch > 1.0:
                result.recommended_action = "Investigate balance discrepancy"
            else:
                result.recommended_action = "Minor discrepancy - monitor"
        
        # Log the reconciliation
        self.event_logger.log_reconciliation(result)
        
        if not result.is_synced:
            logger.warning(f"Reconciliation failed: {len(result.position_mismatches)} position mismatches, "
                          f"balance diff: ${result.balance_mismatch:.2f}")
        else:
            logger.debug("Reconciliation successful - all positions synced")
        
        return result


class InstitutionalEventSystem:
    """
    Unified interface for institutional-grade event logging,
    transaction cost analysis, and reconciliation.
    """
    
    def __init__(self, data_dir: str = "data"):
        self.data_dir = data_dir
        os.makedirs(data_dir, exist_ok=True)
        
        # Initialize components
        self.event_logger = EventLogger(os.path.join(data_dir, "event_log.db"))
        self.tca = TransactionCostAnalyzer(self.event_logger)
        self.reconciler = PositionReconciler(self.event_logger)
        
        # Background reconciliation
        self._running = False
        self._recon_thread = None
        self._recon_interval = 60  # seconds
        
        logger.info("InstitutionalEventSystem initialized")
    
    def start_background_reconciliation(self, interval_seconds: int = 60):
        """Start background reconciliation thread"""
        if self._running:
            return
        
        self._running = True
        self._recon_interval = interval_seconds
        
        def recon_loop():
            while self._running:
                time.sleep(self._recon_interval)
                # Reconciliation will be triggered externally with MT5 data
        
        self._recon_thread = threading.Thread(target=recon_loop, daemon=True)
        self._recon_thread.start()
        logger.info(f"Background reconciliation started (interval: {interval_seconds}s)")
    
    def stop_background_reconciliation(self):
        """Stop background reconciliation"""
        self._running = False
        if self._recon_thread:
            self._recon_thread.join(timeout=5)
    
    def get_summary(self) -> Dict[str, Any]:
        """Get summary of event system state"""
        stats = self.event_logger.get_statistics()
        
        # Get recent TCA
        tca_metrics = self.tca.analyze(days=1)
        
        return {
            'event_log_stats': stats,
            'tca_24h': tca_metrics.to_dict(),
            'slippage_by_session': self.tca.get_slippage_by_session()
        }


# Global instance
_event_system: Optional[InstitutionalEventSystem] = None


def get_event_system() -> InstitutionalEventSystem:
    """Get or create the global event system"""
    global _event_system
    if _event_system is None:
        _event_system = InstitutionalEventSystem()
    return _event_system


# Convenience functions
def log_decision_cycle(symbol: str) -> str:
    """Start logging a decision cycle"""
    return get_event_system().event_logger.start_decision_cycle(symbol)


def log_market_snapshot(cycle_id: str, snapshot: MarketSnapshot):
    """Log market snapshot"""
    get_event_system().event_logger.log_market_snapshot(cycle_id, snapshot)


def log_signal(cycle_id: str, signal: SignalEvent, is_selected: bool = False):
    """Log a signal"""
    get_event_system().event_logger.log_signal(cycle_id, signal, is_selected)


def log_confidence_adjustment(cycle_id: str, adjustment: ConfidenceAdjustment):
    """Log confidence adjustment"""
    get_event_system().event_logger.log_confidence_adjustment(cycle_id, adjustment)


def log_gate_check(cycle_id: str, result: GateCheckResult):
    """Log gate check result"""
    get_event_system().event_logger.log_gate_check(cycle_id, result)


def log_trade_decision(cycle_id: str, decision: str, reason: str = ""):
    """Log trade decision"""
    get_event_system().event_logger.log_trade_decision(cycle_id, decision, reason)


def end_decision_cycle(cycle_id: str, processing_time_ms: float = 0.0):
    """End decision cycle"""
    get_event_system().event_logger.end_decision_cycle(cycle_id, processing_time_ms)


def record_trade_for_tca(symbol: str, direction: str, intended_price: float, 
                         actual_price: float, spread: float, size: float, pnl: float = 0.0):
    """Record trade for TCA"""
    get_event_system().tca.record_trade(symbol, direction, intended_price, actual_price, spread, size, pnl)


def reconcile_positions(mt5_positions: Dict, mt5_balance: float) -> ReconciliationResult:
    """Reconcile positions with MT5"""
    return get_event_system().reconciler.reconcile(mt5_positions, mt5_balance)


if __name__ == "__main__":
    # Test the event system
    logging.basicConfig(level=logging.INFO)
    
    system = get_event_system()
    
    # Test decision cycle logging
    cycle_id = system.event_logger.start_decision_cycle("EURUSD")
    
    # Log market snapshot
    snapshot = MarketSnapshot(
        timestamp=datetime.now(),
        symbol="EURUSD",
        bid=1.1000,
        ask=1.1002,
        spread_pips=2.0,
        rsi=55.0,
        adx=30.0,
        atr=0.0015,
        regime="trending"
    )
    system.event_logger.log_market_snapshot(cycle_id, snapshot)
    
    # Log signal
    signal = SignalEvent(
        timestamp=datetime.now(),
        symbol="EURUSD",
        strategy="session_breakout",
        direction="BUY",
        base_confidence=0.72,
        entry_reason="London session breakout with strong momentum"
    )
    system.event_logger.log_signal(cycle_id, signal, is_selected=True)
    
    # Log confidence adjustment
    adjustment = ConfidenceAdjustment(
        source="macro",
        original_confidence=0.72,
        adjusted_confidence=0.75,
        adjustment_factor=1.04,
        reason="Risk-on regime favors EUR"
    )
    system.event_logger.log_confidence_adjustment(cycle_id, adjustment)
    
    # Log gate check
    gate = GateCheckResult(
        gate_name="spread_gate",
        passed=True,
        reason="Spread 2.0 pips within limit",
        details={'spread': 2.0, 'limit': 3.0}
    )
    system.event_logger.log_gate_check(cycle_id, gate)
    
    # Log decision
    system.event_logger.log_trade_decision(cycle_id, "trade", "All gates passed")
    
    # End cycle
    system.event_logger.end_decision_cycle(cycle_id, processing_time_ms=150.5)
    
    # Test TCA
    system.tca.record_trade("EURUSD", "BUY", 1.1000, 1.1001, 2.0, 0.01, 5.50)
    tca_report = system.tca.analyze()
    print(f"TCA Report: {tca_report.to_dict()}")
    
    # Test reconciliation
    system.reconciler.update_internal_state(
        {'EURUSD': {'size': 0.01, 'direction': 'BUY'}},
        100.0
    )
    recon = system.reconciler.reconcile(
        {'EURUSD': {'size': 0.01, 'direction': 'BUY'}},
        100.0
    )
    print(f"Reconciliation: synced={recon.is_synced}")
    
    # Get statistics
    stats = system.event_logger.get_statistics()
    print(f"Statistics: {stats}")
    
    print("Event system test completed successfully!")
